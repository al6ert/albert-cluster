name: Dev CI Enhanced

on:
  push:
    branches: [dev]
  pull_request:
    branches: [dev]
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: read

env:
  HELM_VERSION: v3.18.3
  HELMFILE_VERSION: v1.1.2
  YQ_VERSION: v4.40.5

jobs:
  build-test-dev:
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      # -------- Herramientas --------------------------------------------------
      - name: Cache Helm plugins & charts
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/helm
            ~/.local/share/helm
          key: ${{ runner.os }}-helm-${{ env.HELM_VERSION }}

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: ${{ env.HELM_VERSION }}

      - name: Install Helmfile
        uses: helmfile/helmfile-action@v2.0.4
        with:
          helmfile-version: ${{ env.HELMFILE_VERSION }}
          helm-version: ${{ env.HELM_VERSION }}
          helmfile-args: version

      - name: Install yq
        run: |
          curl -sSL "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64" \
            -o /usr/local/bin/yq && sudo chmod +x /usr/local/bin/yq

      # -------- Setup Minikube --------------------------------------------------
      - name: Cache Minikube
        uses: actions/cache@v4
        with:
          path: ~/.minikube/cache/
          key: ${{ runner.os }}-minikube-cache-${{ github.sha }}

      - name: Setup Minikube
        uses: medyagh/setup-minikube@v0.0.15
        with:
          driver: docker
          kubernetes-version: v1.30.2
          cpus: 4
          memory: 8192mb
          profile: minikube-${{ github.sha }}

      - name: Configure Minikube profile
        run: |
          minikube profile minikube-${{ github.sha }}
          minikube addons disable ingress
          minikube addons disable storage-provisioner

      # -------- ValidaciÃ³n y Linting -----------------------------------------
      - name: Render manifests (minikube)
        run: |
          echo "::group::Render"
          cd infra/apps
          mkdir -p ../rendered/minikube
          helmfile --environment minikube template > ../rendered/minikube/all.yaml
          echo "::endgroup::"

      - name: Validate YAML syntax
        run: |
          python3 - <<'PY'
          import yaml, sys
          yaml.safe_load_all(open('infra/rendered/minikube/all.yaml'))
          print("âœ… YAML vÃ¡lido")
          PY

      - name: Bootstrap All (Enfoque por Fases Robustas)
        run: |
          cd infra/bootstrap
          set -euo pipefail
          
          echo "::group::ðŸ“¦ Fase 0: Verificar CRDs de ArgoCD"
          # Los CRDs de ArgoCD esenciales estÃ¡n incluidos en crds/argocd-application-crd.yaml
          # Se aplicarÃ¡n automÃ¡ticamente en la Fase 1 con el resto de CRDs
          if ! kubectl get crd applications.argoproj.io >/dev/null 2>&1; then
            echo "ðŸ“‹ CRDs de ArgoCD no existen - se instalarÃ¡n en Fase 1"
          else
            echo "âœ… CRDs de ArgoCD ya existen"
          fi
          echo "::endgroup::"
          
          echo "::group::ðŸ—ï¸ Fase 1: Namespaces + CRDs + RBAC"
          # Aplicar solo namespaces, CRDs y RBAC primero
          kubectl apply -k namespaces/
          kubectl apply -k crds/ --validate=false
          kubectl apply -f rbac/gh-actions.yaml
          echo "::endgroup::"
          
          echo "::group::â³ Fase 2: Esperando CRDs Established"
          # Esperar que TODOS los CRDs estÃ©n established con timeout aumentado
          echo "Esperando CRDs established (timeout: 180s)..."
          kubectl get crd -o name | grep -E 'cert-manager.io|traefik.io|acme.cert-manager.io|bitnami.com|argoproj.io' | \
            xargs kubectl wait --for=condition=Established --timeout=180s
          echo "âœ… Todos los CRDs estÃ¡n established"
          echo "::endgroup::"
          
          echo "::group::ðŸ” Fase 3: SealedSecrets + Middlewares"
          # Aplicar recursos dependientes de CRDs
          kubectl apply -k secrets/
          kubectl apply -k middlewares/
          echo "::endgroup::"
          
          echo "::group::ðŸš€ Fase 4: ArgoCD Applications"
          # Aplicar Applications de ArgoCD al final
          kubectl apply -f argocd-root.yaml -f argocd-minikube.yaml
          echo "::endgroup::"
          
          echo "::group::ðŸ” Fase 5: VerificaciÃ³n Final"
          echo "â³ Esperando unsealing de SealedSecrets..."
          # Esperar unsealing con mejor manejo de errores
          for ss in $(kubectl get sealedsecrets -A -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null || echo ""); do
            if [ -n "$ss" ]; then
              ns=$(echo $ss | cut -d' ' -f1)
              name=$(echo $ss | cut -d' ' -f2)
              echo "  - Unsealing $name en namespace $ns..."
              kubectl wait sealedsecret/$name -n $ns --for=condition=Sealed=true --timeout=120s || echo "    âš ï¸  Unsealing de $name fallÃ³"
            fi
          done
          
          # VerificaciÃ³n final de estado
          echo "ðŸ“‹ Estado final de recursos:"
          echo "  Namespaces: $(kubectl get ns | grep -E '(admin|argocd|cert-manager)' | wc -l)"
          echo "  CRDs: $(kubectl get crd | grep -E '(cert-manager|traefik|bitnami|argoproj)' | wc -l)"
          echo "  Applications: $(kubectl get applications -n argocd --no-headers 2>/dev/null | wc -l)"
          echo "  SealedSecrets: $(kubectl get sealedsecrets -A --no-headers 2>/dev/null | wc -l)"
          echo "  Middlewares: $(kubectl get middlewares -A --no-headers 2>/dev/null | wc -l)"
          echo "::endgroup::"
          
          echo "âœ… Bootstrap completado exitosamente con enfoque por fases"

      - name: Helmfile lint
        run: |
          cd infra/apps
          helmfile --environment minikube lint

      - name: Helmfile diff (fail on destructive changes)
        run: |
          cd infra/apps
          helm repo update  # Agrega esto: Actualiza todos los repos (incluyendo traefik y jetstack)
          helmfile --environment minikube diff --detailed-exitcode --no-color > diff.log || status=$?
          if [ "$status" = 2 ] && grep -qE 'REMOVED|DELETED' diff.log; then
            echo "::error::Helmfile diff contiene eliminaciones destructivas"
            echo "::group::Diff log"
            cat diff.log
            echo "::endgroup::"
            exit 1
          elif [ "$status" -ne 0 ] && [ "$status" -ne 2 ]; then
            echo "::error::Helmfile diff failed with status $status"
            echo "::group::Diff log"
            cat diff.log
            echo "::endgroup::"
            exit $status
          fi
          echo "âœ… Helmfile diff passed - no destructive changes detected"

      - name: Pre-pull images
        run: minikube ssh 'docker pull traefik:v3.4.3'    

        # -------- Despliegue y Tests de Humo -----------------------------------


      - name: Deploy to Minikube - Main Apps
        run: |
          cd infra/apps
          # Apply todas las aplicaciones (Cert-Manager, Traefik, etc.)
          # El middleware de autenticaciÃ³n se aplica desde extraObjects de Traefik
          helmfile --environment minikube apply --suppress-secrets


      - name: Debug Traefik pods if fail
        if: always()
        run: |
          kubectl get pods -n traefik
          kubectl describe pod -n traefik -l app.kubernetes.io/name=traefik
          kubectl logs -n traefik -l app.kubernetes.io/name=traefik  # Agrega esto: logs actuales
          kubectl logs -n traefik -l app.kubernetes.io/name=traefik --previous || echo "No previous logs"


      - name: Wait for pods to be ready
        run: |
          kubectl wait pod --all -A --for=condition=Ready --timeout=300s

      - name: Check for crashloops
        run: |
          CRASHED_PODS=$(kubectl get pods --all-namespaces --field-selector=status.phase!=Running -o jsonpath='{.items[*].metadata.name}')
          if [ -n "$CRASHED_PODS" ]; then
            echo "::error::Found pods not in Running state:"
            kubectl get pods --all-namespaces --field-selector=status.phase!=Running
            exit 1
          fi
          echo "âœ… All pods are running"

      - name: Smoke tests
        run: |
          # Test 1: Hello app should return 200
          echo "Testing hello app..."
          kubectl port-forward svc/hello 8080:80 -n traefik &
          sleep 5
          curl -f http://localhost:8080/ || {
            echo "::error::Hello app not responding"
            exit 1
          }
          pkill -f "kubectl port-forward"

          # Test 2: Traefik dashboard should require auth (401)
          echo "Testing Traefik dashboard auth..."
          kubectl port-forward svc/traefik 8080:9000 -n traefik &
          sleep 5
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/dashboard/)
          if [ "$HTTP_CODE" != "401" ]; then
            echo "::error::Traefik dashboard should return 401 (auth required), got $HTTP_CODE"
            exit 1
          fi
          pkill -f "kubectl port-forward"

          echo "âœ… All smoke tests passed"

      # -------- Limpieza -----------------------------------------------------
      - name: Cleanup Minikube
        if: always()
        run: |
          minikube delete -p minikube-${{ github.sha }}

      # -------- Commit rendered manifests ------------------------------------
      - name: Commit rendered manifests
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add infra/rendered/minikube
          git commit -m "ci: render minikube manifests $(date +%F-%T)" || echo "No changes to commit"
          git push 