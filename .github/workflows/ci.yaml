name: CI/CD Pipeline

on:
  push:
    branches: [main, dev]
  pull_request:
    branches: [main]
  release:
    types: [published]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

permissions:
  contents: read
  security-events: write
  packages: write

# ─────────────────────────────────────────────
# 1) Validación de sintaxis y linting
# ─────────────────────────────────────────────
jobs:
  validate:
    name: Validate & Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Helm (solo para lint; no plugins necesarios)
      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Helm lint custom charts
        run: |
          if [ -d "infra/charts" ]; then
            find infra/charts -name "Chart.yaml" -exec dirname {} \; \
              | xargs -I {} helm lint {}
          fi

      - name: Validate Kustomize output
        run: |
          if [ -f "infra/bootstrap/kustomization.yaml" ]; then
            kubectl kustomize infra/bootstrap/ > /tmp/k.yaml
            [ -s /tmp/k.yaml ] || { echo "❌ Kustomize generó salida vacía"; exit 1; }
            echo "✅ Kustomize generó $(wc -l < /tmp/k.yaml) líneas"
          else
            echo "ℹ️ Sin kustomization en infra/bootstrap/"
          fi

# ─────────────────────────────────────────────
# 2) Análisis de seguridad
# ─────────────────────────────────────────────
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - uses: actions/checkout@v4

      - name: Run Trivy (fs)
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: fs
          scan-ref: .
          format: sarif
          output: trivy-results.sarif

      - name: Upload Trivy results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: trivy-results.sarif

# ─────────────────────────────────────────────
# 3) Tests (unit + integración en kind)
# ─────────────────────────────────────────────
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: [validate, security]
    steps:
      - uses: actions/checkout@v4

      - name: Set up Helm
        uses: azure/setup-helm@v3

      - name: Install helm-unittest plugin
        run: |
          helm plugin install https://github.com/quintush/helm-unittest

      - name: Run chart unit tests
        run: |
          if [ -d "infra/charts" ]; then
            find infra/charts -name "Chart.yaml" -exec dirname {} \; \
              | xargs -I {} helm unittest {}
          fi

      # Clúster kind para pruebas de integración
      - name: Set up kind
        uses: helm/kind-action@v1
        with:
          node_image: kindest/node:v1.28.0

      - name: Bootstrap lightweight Argo CD
        run: |
          kubectl create ns argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -f infra/bootstrap/argocd.yaml
          kubectl wait --for=condition=established crd/applications.argoproj.io --timeout=60s
          kubectl apply -f infra/bootstrap/argocd-root.yaml
          kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=argocd-server -n argocd --timeout=300s

      - name: Smoke integration tests
        run: |
          echo "⏱ Esperando sincronización automática…"
          sleep 30
          kubectl get applications -n argocd
          kubectl get pods -A

# ─────────────────────────────────────────────
# 4) GitOps → producción (validación + confiar en sincronización automática)
# ─────────────────────────────────────────────
  gitops-deploy:
    name: GitOps Validation & Auto-Sync
    runs-on: ubuntu-latest
    environment: production
    needs: test
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      # Kubeconfig (solo lectura)
      - name: Setup kubeconfig (RO)
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.NETCUP_KUBECONFIG_RO }}" > ~/.kube/config
          chmod 600 ~/.kube/config
          kubectl get nodes

      # Validación rápida de los manifests de las Argo CD Applications
      - name: Validate Argo CD Applications manifests
        run: |
          kubectl apply --dry-run=client -f infra/apps/traefik/argocd-application.yaml
          kubectl apply --dry-run=client -f infra/apps/hello/argocd-application.yaml
          echo "✅ Manifests válidos"

      - name: Validate CRDs
        run: kubectl apply --dry-run=client -f infra/bootstrap/crds/

      # Verificar que ArgoCD está funcionando y confiar en sincronización automática
      - name: Verify ArgoCD is running
        run: |
          kubectl get pods -n argocd -l app.kubernetes.io/name=argocd-server
          echo "✅ ArgoCD está funcionando - la sincronización será automática"

      # Verificar que ArgoCD está listo para sincronización automática

# ─────────────────────────────────────────────
# 5) Verificación post-deploy
# ─────────────────────────────────────────────
  verify:
    name: Post-deployment Verification
    runs-on: ubuntu-latest
    needs: gitops-deploy
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    steps:
      - uses: actions/checkout@v4

      - name: Setup kubeconfig (RO)
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.NETCUP_KUBECONFIG_RO }}" > ~/.kube/config
          chmod 600 ~/.kube/config

      # Espera a que las aplicaciones estén Healthy y Synced
      - name: Wait for Argo CD applications to be Healthy
        run: |
          # Verificar estado general de las aplicaciones
          kubectl get applications -n argocd -o wide
          
          # Esperar a que estén saludables (más permisivo)
          kubectl wait --for=jsonpath='{.status.health.status}=Healthy' \
            application/traefik -n argocd --timeout=300s || echo "⚠️ Traefik health check timeout"
          kubectl wait --for=jsonpath='{.status.health.status}=Healthy' \
            application/hello -n argocd --timeout=300s || echo "⚠️ Hello health check timeout"

      - name: Health checks
        run: |
          # Verificar si los pods están corriendo (más robusto)
          echo "🔍 Verificando estado de las aplicaciones..."
          
          # Traefik
          if kubectl get pods -n traefik -l app.kubernetes.io/name=traefik 2>/dev/null; then
            kubectl wait --for=condition=ready \
              pod -l app.kubernetes.io/name=traefik -n traefik --timeout=300s || echo "⚠️ Traefik pods not ready"
          else
            echo "⚠️ No se encontraron pods de Traefik"
          fi
          
          # Hello
          if kubectl get pods -n traefik -l app=hello 2>/dev/null; then
            kubectl wait --for=condition=ready \
              pod -l app=hello -n traefik --timeout=300s || echo "⚠️ Hello pods not ready"
          else
            echo "⚠️ No se encontraron pods de Hello"
          fi
          
          # Estado final
          echo "📊 Estado final:"
          kubectl get applications -n argocd -o wide
          kubectl get pods -A | grep -E "(traefik|hello)" || echo "ℹ️ No se encontraron pods de traefik o hello"

# ─────────────────────────────────────────────
# 6) Notificaciones finales
# ─────────────────────────────────────────────
  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: verify
    if: always()
    steps:
      - name: Notify on success
        if: success()
        run: echo "✅ Deployment successful!"

      - name: Notify on failure
        if: failure()
        run: echo "❌ Deployment failed!"
