name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # Quality Gate: Full integration tests on Pull Requests
  # ============================================================================
  integration-test:
    name: Integration Test
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Tools
        uses: ./.github/actions/setup-tools

      - name: Validate Manifests (minikube)
        uses: ./.github/actions/validate-manifests
        with:
          environment: minikube
          skip-diff: true

      - name: Validate Manifests (netcup)
        uses: ./.github/actions/validate-manifests
        with:
          environment: netcup
          skip-diff: true

      - name: Compare namespace consistency
        run: |
          cd infra/apps
          helmfile --environment minikube template > /tmp/minikube-all.yaml
          helmfile --environment netcup template > /tmp/netcup-all.yaml
          minikube_ns=$(yq e '.metadata.namespace' /tmp/minikube-all.yaml | sort -u | grep -v null)
          netcup_ns=$(yq e '.metadata.namespace' /tmp/netcup-all.yaml | sort -u | grep -v null)

          if [ "$minikube_ns" != "$netcup_ns" ]; then
            echo "::error::Namespaces don't match between environments"
            exit 1
          fi
          echo "✅ Namespaces are consistent across environments"

      - name: Setup Minikube
        uses: medyagh/setup-minikube@v0.0.15
        with:
          driver: docker
          cache: true
          minikube-version: latest
          kubernetes-version: v1.30.2
          cpus: 4
          memory: 12288mb
          wait: all

      - name: Start Minikube Tunnel
        run: |
          sudo -E minikube tunnel --cleanup=false >/dev/null 2>&1 &

      - name: Configure Minikube
        run: |
          minikube profile minikube-${{ github.sha }}
          minikube addons disable ingress
          minikube addons disable storage-provisioner

      - name: Install Dependencies
        run: |
          sudo apt-get update && sudo apt-get install -y apache2-utils

      - name: Deploy Local (Bootstrap & Apps)
        run: |
          chmod +x deploy-local.sh
          ./deploy-local.sh

      - name: Run smoke tests
        run: |
          chmod +x tests/smoke.sh
          WAIT_TIMEOUT=300s ./tests/smoke.sh

      - name: Debug on failure
        if: failure()
        run: |
          kubectl get all -A
          kubectl get events -A --sort-by='.lastTimestamp' | tail -50
          kubectl logs -n cert-manager -l app.kubernetes.io/name=cert-manager --tail=100 || true
          kubectl logs -n traefik -l app.kubernetes.io/name=traefik --tail=100 || true

      - name: Cleanup
        if: always()
        run: |
          minikube delete -p minikube-${{ github.sha }}

  # ============================================================================
  # Deploy to Production: Only on push to main (after PR tests passed)
  # ============================================================================
  promote-prod:
    name: Promote to Production
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    environment: prod

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Tools
        uses: ./.github/actions/setup-tools

      - name: Validate Manifests (netcup)
        uses: ./.github/actions/validate-manifests
        with:
          environment: netcup
          skip-diff: true

      - name: Install ArgoCD CLI
        run: |
          source versions.env
          curl -sSL -o argocd-linux-amd64 "https://github.com/argoproj/argo-cd/releases/download/${ARGOCD_VERSION}/argocd-linux-amd64"
          sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
          rm argocd-linux-amd64

      - name: ArgoCD diff and sync
        run: |
          # Use API hostname for CLI access (bypasses Cloudflare proxy, supports gRPC)
          # ARGOCD_API_SERVER should point to argo-api.albertperez.dev (DNS only, no CF proxy)
          ARGOCD_API_SERVER="${{ secrets.ARGOCD_API_SERVER }}"
          ARGOCD_API_SERVER="${ARGOCD_API_SERVER#https://}"
          ARGOCD_API_SERVER="${ARGOCD_API_SERVER#http://}"
          
          echo "::group::Verify API Connectivity"
          echo "Connecting to ArgoCD API: ${ARGOCD_API_SERVER}"
          curl -sI "https://${ARGOCD_API_SERVER}" | head -5
          echo "::endgroup::"

          echo "::group::ArgoCD Login"
          argocd login "${ARGOCD_API_SERVER}" \
            --username admin \
            --password "${{ secrets.ARGOCD_PASSWORD }}" \
            --grpc-web
          echo "✅ ArgoCD login successful"
          echo "::endgroup::"

          echo "::group::ArgoCD diff"
          argocd app diff cluster-root --grpc-web || {
            echo "::notice::ArgoCD diff detected changes, proceeding with sync"
          }
          echo "::endgroup::"

          echo "::group::ArgoCD sync"
          argocd app sync cluster-root --prune --grpc-web
          echo "::endgroup::"

          echo "::group::Wait for health"
          argocd app wait cluster-root --health --timeout 300 --grpc-web
          echo "✅ ArgoCD sync completed successfully"
          echo "::endgroup::"

