name: Dev CI Enhanced

on:
  push:
    branches: [dev]
  pull_request:
    branches: [dev]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: dev-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test-dev:
    name: Enhanced Development Build and Test
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Comprobar si sudo está disponible
        run: |
          # sudo -n true → devuelve 0 si el usuario puede usar sudo sin interactuar
          if sudo -n true 2>/dev/null; then
            echo "✅ sudo disponible sin contraseña"
          else
            echo "::error::sudo NO disponible o requiere password"
            exit 1
          fi

      - name: Setup Tools
        uses: ./.github/actions/setup-tools
        with:
          cache-key: ${{ runner.os }}-helm-dev-${{ github.sha }}

      - name: Cache Minikube
        uses: actions/cache@v4
        with:
          path: ~/.minikube/cache/
          key: ${{ runner.os }}-minikube-cache-${{ github.sha }}

      - name: Setup Minikube
        uses: medyagh/setup-minikube@v0.0.15
        with:
          driver: docker
          cache: true
          minikube-version: latest
          kubernetes-version: v1.30.2
          cpus: 4
          memory: 12288mb
          wait: all

      - name: Start Minikube Tunnel
        run: |
          sudo -E minikube tunnel --cleanup=false >/dev/null 2>&1 &

      - name: Configure Minikube
        run: |
          minikube profile minikube-${{ github.sha }}
          minikube addons disable ingress
          minikube addons disable storage-provisioner

      - name: Install kubeconform
        run: |
          curl -Lo kubeconform https://github.com/yannh/kubeconform/releases/latest/download/kubeconform-linux-amd64
          chmod +x kubeconform
          sudo mv kubeconform /usr/local/bin/

      - name: Bootstrap cluster (Kustomize-based)
        run: |
          cd infra/bootstrap
          set -euo pipefail

          echo "::group::Phase 1: Apply CRDs with Kustomize"
          kubectl apply -k crds/ --validate=false
          echo "::endgroup::"

          echo "::group::Phase 2: Wait for CRDs Established"
          kubectl get crd -o name | grep -E 'cert-manager.io|traefik.io|acme.cert-manager.io|bitnami.com|argoproj.io' | \
            xargs kubectl wait --for=condition=Established --timeout=180s || {
              echo "⚠️ CRDs not established"
              kubectl get crd -o wide
              exit 1
            }
          echo "::endgroup::"

          echo "::group::Phase 3: Apply Namespaces, RBAC, and Middlewares"
          kubectl apply -k namespaces/
          kubectl apply -f rbac/gh-actions.yaml
          kubectl apply -k middlewares/
          echo "::endgroup::"

          echo "::group::Phase 4: Install cert-manager"
          cd ../apps/cert-manager
          helmfile --environment minikube sync

          # Wait for deployments
          kubectl wait deployment -n cert-manager --all --for=condition=Available --timeout=300s || {
            echo "⚠️ Cert-manager deployments not ready"
            kubectl get deployments -n cert-manager
            kubectl describe deployment -n cert-manager -l app.kubernetes.io/name=cert-manager
            kubectl logs -n cert-manager -l app.kubernetes.io/name=cert-manager --tail=200 || echo "No cert-manager logs available"
            kubectl get events -n cert-manager
            exit 1
          }

          # Wait for Local CA (defined in infra/envs/minikube/cert-manager-values.yaml)
          echo "Waiting for Local CA..."
          kubectl wait certificate/local-ca -n cert-manager --for=condition=Ready --timeout=180s || {
            echo "⚠️ Local CA Certificate not ready"
            kubectl describe certificate local-ca -n cert-manager
            exit 1
          }

          echo "Waiting for Local CA ClusterIssuer..."
          kubectl wait clusterissuer/local-ca-issuer --for=condition=Ready --timeout=180s || {
            echo "⚠️ Local CA ClusterIssuer not ready"
            kubectl describe clusterissuer local-ca-issuer
            exit 1
          }

          echo "✅ Cert-manager and Local CA ready"
          echo "::endgroup::"

          echo "::group::Phase 5: Install SealedSecrets Controller"
          cd ../sealed-secrets
          helmfile --environment minikube sync
          kubectl wait deployment/sealed-secrets -n kube-system --for=condition=Available --timeout=300s || {
            echo "⚠️ SealedSecrets controller not ready"
            kubectl logs -n kube-system -l app.kubernetes.io/name=sealed-secrets --tail=200
            kubectl get events -n kube-system
            exit 1
          }
          cd ../../bootstrap
          echo "::endgroup::"

          echo "::group::Phase 7: Generate and Apply Sealed Secrets (Dynamic for CI)"
          sudo apt-get update && sudo apt-get install -y apache2-utils
          ../../scripts/generate-credentials.sh --namespace admin --users admin --secret-name admin-basic-auth
          kubectl apply -f secrets/admin-basic-auth-sealed.yaml

          echo "::group::Generate Cloudflare dummy secret"
          cat <<EOF | kubeseal --controller-name=sealed-secrets --controller-namespace=kube-system --format yaml > secrets/cloudflare-api-token-sealed.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: cloudflare-api-token
            namespace: cert-manager
          type: Opaque
          stringData:
            api-token: dummy-token-for-ci
          EOF
          kubectl apply -f secrets/cloudflare-api-token-sealed.yaml
          echo "::endgroup::"

          echo "::endgroup::"

          echo "::group::Phase 8: Wait for SealedSecrets Unsealing"
          while read -r ss; do
            if [ -n "$ss" ]; then
              ns=$(echo "$ss" | cut -d' ' -f1)
              name=$(echo "$ss" | cut -d' ' -f2)
              echo "  - Unsealing $name in namespace $ns..."
              kubectl wait sealedsecret/$name -n $ns --for=condition=Synced --timeout=180s || {
                echo "⚠️ Failed to unseal $name in $ns"
                kubectl describe sealedsecret/$name -n $ns
                kubectl logs -n kube-system -l app.kubernetes.io/name=sealed-secrets --tail=200
                kubectl get events -n kube-system
                exit 1
              }
              echo "✅ $name unsealed"
            fi
          done < <(kubectl get sealedsecrets -A -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null)

          echo "Checking unsealed Secrets:"
          kubectl get secret admin-basic-auth -n admin || {
            echo "⚠️ admin-basic-auth Secret not found"
            kubectl logs -n kube-system -l app.kubernetes.io/name=sealed-secrets --tail=200
            kubectl get events -n kube-system
            exit 1
          }
          kubectl get secret cloudflare-api-token -n cert-manager || {
            echo "⚠️ cloudflare-api-token Secret not found"
            kubectl logs -n kube-system -l app.kubernetes.io/name=sealed-secrets --tail=200
            kubectl get events -n kube-system
            exit 1
          }
          echo "::endgroup::"

          echo "::group::Phase 9: Apply ArgoCD Apps"
          kubectl apply -f argocd-minikube.yaml
          echo "::endgroup::"

      - name: Validate Manifests (minikube)
        uses: ./.github/actions/validate-manifests
        with:
          environment: minikube
          working-directory: infra/apps
          skip-diff: true
        env:
          KUBECONFORM_ARGS: -schema-location default -schema-location 'https://raw.githubusercontent.com/traefik/traefik/v3.4.3/traefik.crds.yaml'

      - name: Pre-pull container images
        run: |
          source versions.env
          minikube ssh "docker pull traefik:v3.4.3; docker pull quay.io/jetstack/cert-manager-controller:v1.18.2"

      - name: Deploy applications to Minikube
        run: |
          cd infra/apps
          # Desplegar solo Traefik y aplicaciones posteriores, ya que cert-manager y sealed-secrets ya están desplegados
          helmfile --environment minikube sync --selector 'name!=cert-manager,name!=sealed-secrets'
          kubectl wait deployment -n traefik --all --for=condition=Available --timeout=300s || {
            echo "⚠️ Traefik deployments not ready"
            kubectl get deployments -n traefik
            kubectl describe deployment -n traefik traefik
            kubectl logs -n traefik -l app.kubernetes.io/name=traefik --tail=200 || echo "No logs available"
            kubectl get events -n traefik
            kubectl describe certificate -n traefik wildcard-minikube
            exit 1
          }
          kubectl wait certificate/wildcard-minikube -n traefik --for=condition=Ready --timeout=180s || {
            echo "⚠️ Certificate wildcard-minikube not ready"
            kubectl describe certificate wildcard-minikube -n traefik
            kubectl logs -n cert-manager -l app.kubernetes.io/name=cert-manager --tail=200 || echo "No cert-manager logs available"
            exit 1
          }
          kubectl get secret -n traefik wildcard-minikube-tls || {
            echo "⚠️ Secret wildcard-minikube-tls not found"
            kubectl describe certificate wildcard-minikube -n traefik
            exit 1
          }
          echo "✅ Certificate wildcard-minikube-tls ready"

      - name: Debug Traefik if deployment fails
        if: failure()
        run: |
          kubectl get all -n traefik
          kubectl describe deployment -n traefik traefik
          kubectl logs -n traefik -l app.kubernetes.io/name=traefik --tail=200 || echo "No logs available"
          kubectl get events -n traefik
          kubectl describe certificate -n traefik wildcard-minikube
          kubectl logs -n cert-manager -l app.kubernetes.io/name=cert-manager --tail=200 || echo "No cert-manager logs available"
          kubectl logs -n kube-system -l app.kubernetes.io/name=sealed-secrets --tail=200 || echo "No sealed-secrets logs available"
          kubectl get events -n cert-manager
          kubectl get events -n kube-system

      - name: Wait for applications to be ready
        run: |


          echo "::group::Wait for Traefik"
          kubectl wait deployment -n traefik --all --for=condition=Available --timeout=300s
          echo "::endgroup::"

          echo "::group::Wait for Hello App"
          kubectl wait deployment -n hello --all --for=condition=Available --timeout=300s
          echo "::endgroup::"

      - name: Check for crashloops
        run: |
          # Check for pods with actual error states, ignoring Completed jobs
          CRASHED_PODS=$(kubectl get pods -A | grep -v "Completed" | grep -E "CrashLoopBackOff|ImagePullBackOff|ErrImagePull|Error" || true)

          if [ -n "$CRASHED_PODS" ]; then
            echo "::error::Found pods in error state:"
            echo "$CRASHED_PODS"
            kubectl get pods -A -o wide
            exit 1
          fi
          echo "✅ No crashloops found"

      - name: Enhanced smoke tests
        run: |
          chmod +x tests/smoke.sh
          WAIT_TIMEOUT=300s ./tests/smoke.sh

      - name: Cleanup Minikube
        if: always()
        run: |
          minikube delete -p minikube-${{ github.sha }}
