name: Dev CI Enhanced

on:
  push:
    branches: [dev]
  pull_request:
    branches: [dev]
  workflow_dispatch:

permissions:
  contents: read
  pull-requests: read

concurrency:
  group: dev-ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  build-test-dev:
    name: Enhanced Development Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Tools
        uses: ./.github/actions/setup-tools
        with:
          cache-key: ${{ runner.os }}-helm-dev-${{ github.sha }}

      - name: Cache Minikube
        uses: actions/cache@v4
        with:
          path: ~/.minikube/cache/
          key: ${{ runner.os }}-minikube-cache-${{ github.sha }}

      - name: Setup Minikube
        uses: medyagh/setup-minikube@v0.0.15
        with:
          driver: docker
          kubernetes-version: v1.30.2
          cpus: 4
          memory: 8192mb
          profile: minikube-${{ github.sha }}

      - name: Configure Minikube
        run: |
          minikube profile minikube-${{ github.sha }}
          minikube addons disable ingress
          minikube addons disable storage-provisioner     

      - name: Bootstrap cluster (Enhanced phased approach)
        run: |
          cd infra/bootstrap
          set -euo pipefail
          
          echo "::group::📦 Phase 0: Verify ArgoCD CRDs"
          if ! kubectl get crd applications.argoproj.io >/dev/null 2>&1; then
            echo "📋 ArgoCD CRDs don't exist - will install in Phase 1"
          else
            echo "✅ ArgoCD CRDs already exist"
          fi
          echo "::endgroup::"
          
          echo "::group::🏗️ Phase 1: Namespaces + CRDs + RBAC"
          kubectl apply -k namespaces/
          kubectl apply -k crds/ --validate=false
          kubectl apply -f rbac/gh-actions.yaml
          echo "::endgroup::"
          
          echo "::group::⏳ Phase 2: Wait for CRDs Established"
          echo "Waiting for CRDs to be established (timeout: 180s)..."
          kubectl get crd -o name | grep -E 'cert-manager.io|traefik.io|acme.cert-manager.io|bitnami.com|argoproj.io' | \
            xargs kubectl wait --for=condition=Established --timeout=180s
          echo "✅ All CRDs are established"
          echo "::endgroup::"
          
          echo "::group::🔐 Phase 3: SealedSecrets + Middlewares"
          kubectl apply -k secrets/
          kubectl apply -k middlewares/
          echo "::endgroup::"
          
          echo "::group::🚀 Phase 4: ArgoCD Applications"
          kubectl apply -f argocd-root.yaml -f argocd-minikube.yaml --validate=false
          echo "✅ ArgoCD Applications applied successfully"
          echo "::endgroup::"
          
          echo "::group::🔍 Phase 5: Final verification"
          echo "⏳ Waiting for SealedSecrets unsealing..."
          for ss in $(kubectl get sealedsecrets -A -o jsonpath='{range .items[*]}{.metadata.namespace}{" "}{.metadata.name}{"\n"}{end}' 2>/dev/null || echo ""); do
            if [ -n "$ss" ]; then
              ns=$(echo $ss | cut -d' ' -f1)
              name=$(echo $ss | cut -d' ' -f2)
              echo "  - Unsealing $name in namespace $ns..."
              kubectl wait sealedsecret/$name -n $ns --for=condition=Sealed=true --timeout=120s || echo "    ⚠️ Unsealing of $name failed"
            fi
          done
          
          echo "📋 Final resource state:"
          echo "  Namespaces: $(kubectl get ns | grep -E '(admin|argocd|cert-manager)' | wc -l)"
          echo "  CRDs: $(kubectl get crd | grep -E '(cert-manager|traefik|bitnami|argoproj)' | wc -l)"
          echo "  Applications: $(kubectl get applications -n argocd --no-headers 2>/dev/null | wc -l)"
          echo "  SealedSecrets: $(kubectl get sealedsecrets -A --no-headers 2>/dev/null | wc -l)"
          echo "  Middlewares: $(kubectl get middlewares -A --no-headers 2>/dev/null | wc -l)"
          echo "::endgroup::"
          
          echo "✅ Bootstrap completed successfully with enhanced phased approach"

      - name: Validate Manifests (minikube)
        uses: ./.github/actions/validate-manifests
        with:
          environment: minikube    

      - name: Pre-pull container images
        run: |
          source versions.env
          minikube ssh "docker pull traefik:v3.4.3; docker pull quay.io/jetstack/cert-manager-controller:v1.18.2"

      - name: Deploy applications to Minikube
        run: |
          cd infra/apps
          helmfile --environment minikube apply --suppress-secrets --timeout 900s
          kubectl wait deployment -n cert-manager --all --for=condition=Available --timeout=300s || true

      - name: Debug Traefik if deployment fails
        if: failure()
        run: |
          kubectl get pods -n traefik
          kubectl describe pod -n traefik -l app.kubernetes.io/name=traefik
          kubectl logs -n traefik -l app.kubernetes.io/name=traefik || echo "No current logs"
          kubectl logs -n traefik -l app.kubernetes.io/name=traefik --previous || echo "No previous logs"

      - name: Wait for all pods to be ready
        run: |
          kubectl wait pod --all -A --for=condition=Ready --timeout=300s

      - name: Check for crashloops
        run: |
          CRASHED_PODS=$(kubectl get pods --all-namespaces --field-selector=status.phase!=Running -o jsonpath='{.items[*].metadata.name}')
          if [ -n "$CRASHED_PODS" ]; then
            echo "::error::Found pods not in Running state:"
            kubectl get pods --all-namespaces --field-selector=status.phase!=Running
            exit 1
          fi
          echo "✅ All pods are running"

      - name: Enhanced smoke tests
        run: |
          chmod +x tests/smoke.sh
          ./tests/smoke.sh

      - name: Cleanup Minikube
        if: always()
        run: |
          minikube delete -p minikube-${{ github.sha }} 